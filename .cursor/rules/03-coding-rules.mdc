---
alwaysApply: true
---
# コーディング規約

## TypeScript
- 型安全性を重視
- `any`の使用は最小限に（型エラー回避時のみ）
- インターフェースを適切に定義（`types/index.ts`参照）
- 非同期処理は`async/await`を使用

## React
- 関数コンポーネントを使用
- Hooksを適切に活用
- プロップスの型定義を必須とする
- useEffectの依存配列を正確に指定
- `memo`でコンポーネントメモ化（必要に応じて）

## Supabase クライアント
- Supabaseクライアントを直接使用してデータアクセス
- Server Componentでは`createServerClient`を使用
- Client Componentでは`createClient`を使用
- クエリビルダーを活用して型安全なクエリを記述
- エラーハンドリングはtry-catchで実装
- RLS（Row Level Security）でセキュリティを確保

## データベース
- テーブル名とカラム名は**snake_case**で統一
- RLS（Row Level Security）を必ず設定
- マイグレーションファイルで変更管理
- 外部キー制約を適切に設定

## 命名規則

### 基本ルール

1. **データベース層（snake_case）**
   - データベースカラム名: `user_id`, `competition_id`, `practice_id`, `place`, `entry_time`, `split_time`, `pool_type`, `name_jp`
   - データベーステーブル名: `practices`, `competitions`, `records`, `entries`
   - データベース型定義（`apps/shared/types/database.ts`）のプロパティ
   - Supabase型定義（`apps/web/lib/supabase.ts`）のプロパティ

2. **UI層・アプリケーション層（camelCase）**
   - TypeScript変数名: `userId`, `competitionId`, `practiceId`, `styleId`
   - 関数パラメータ名: `userId: string`, `competitionId: string`
   - UI型定義（`apps/shared/types/ui.ts`）のプロパティ
   - フォーム型定義（`apps/web/stores/types.ts`）のプロパティ
   - コンポーネントPropsのプロパティ名

3. **場所を示すフィールド: `place`に統一**
   - `location`は使用しない。データベースもUI層も`place`を使用
   - 例: `CalendarItem.place`, `Practice.place`, `Competition.place`
   - 詳細は `docs/NAMING_CONVENTIONS.md` を参照

### データベース型とUI型の変換

データベースから取得したデータをUI層で使用する際は、必要に応じて`camelCase`に変換：

```typescript
// ✅ データベースから取得（snake_case）
const { data: entry } = await supabase.from('entries').select('*').single()

// ✅ UI型に変換（camelCase）
const entryWithStyle: EntryWithStyle = {
  id: entry.id,
  competitionId: entry.competition_id,  // snake_case → camelCase
  userId: entry.user_id,                // snake_case → camelCase
  styleId: entry.style_id,              // snake_case → camelCase
  entryTime: entry.entry_time,          // snake_case → camelCase
  teamId: entry.team_id                 // snake_case → camelCase
}
```

### よくある間違い

```typescript
// ❌ 間違い: 変数名でsnake_caseを使用
const user_id = user.id
const competition_id = data.competition_id

// ✅ 正しい: camelCaseを使用
const userId = user.id
const competitionId = data.competitionId

// ❌ 間違い: UI型でsnake_caseを使用
export interface EditingData {
  competition_id?: string | null
  practice_id?: string
}

// ✅ 正しい: camelCaseを使用
export interface EditingData {
  competitionId?: string | null
  practiceId?: string
}

// ❌ 間違い: locationを使用
export interface CalendarItem {
  location?: string
}

// ✅ 正しい: placeを使用
export interface CalendarItem {
  place?: string
}
```

## フォーム処理
- **useState**を使用（React Hook Formは未使用）
- バリデーションを適切に実装
- エラーメッセージは日本語で表示
- 楽観的更新でUX向上

## 日付・時間処理
- **date-fns**ライブラリを使用
- タイムゾーンを考慮した実装
- フォーマットは日本語ロケールを使用
- タイム入力は「分・秒」形式

## UI/UX
- レスポンシブデザインを実装
- Tailwind CSSのユーティリティクラスを活用
- ローディング状態を適切に表示
- エラー状態のハンドリングを実装
- モーダルは適切にクローズ処理

## Next.js App Router

### Server Components vs Client Components
- **デフォルトはServer Component** - `'use client'`は必要な時だけ
- **Client Componentが必要な場合**:
  - useState, useEffect, イベントハンドラーを使う時
  - ブラウザAPIを使う時（localStorage, windowなど）
  - カスタムフック（useAuth, useQueryなど）を使う時
- **Server Componentの利点を活用**:
  - データベース直接アクセス
  - 環境変数の安全な使用
  - バンドルサイズの削減

### データフェッチング
```typescript
// ✅ Server Component（推奨）
async function DashboardPage() {
  const supabase = await createAuthenticatedServerClient()
  const { data } = await supabase.from('practices').select('*')
  return <View data={data || []} />
}

// ✅ Client Component（インタラクティブな場合）
'use client'
function InteractiveList() {
  const { supabase } = useAuth()
  const [data, setData] = useState([])
  
  useEffect(() => {
    const fetchData = async () => {
      const { data } = await supabase.from('practices').select('*')
      setData(data || [])
    }
    fetchData()
  }, [supabase])
  
  return <List data={data} />
}
```

### ルーティング
- 動的ルート: `[id]`フォルダを使用
- ルートグループ: `(authenticated)`で認証状態別に整理
- プライベートフォルダ: `_components`でルーティングから除外
- `loading.tsx`でサスペンス境界
- `error.tsx`でエラー境界

## パフォーマンス最適化

### コンポーネント最適化
```typescript
// ✅ React.memoで不要な再レンダリング防止
const CalendarDay = memo(({ date, entries }: Props) => {
  return <div>...</div>
})

// ✅ useCallbackでコールバック安定化
const handleClick = useCallback((id: string) => {
  onSelect(id)
}, [onSelect])

// ✅ useMemoで重い計算をキャッシュ
const sortedData = useMemo(() => 
  data.sort((a, b) => a.date - b.date),
  [data]
)
```

### 動的インポート
```typescript
// ✅ 大きなコンポーネントは遅延読み込み
const HeavyComponent = dynamic(() => import('./HeavyComponent'), {
  loading: () => <Skeleton />,
  ssr: false
})
```

### 画像最適化
```typescript
// ✅ Next.js Imageコンポーネント使用
import Image from 'next/image'

<Image
  src="/profile.jpg"
  alt="プロフィール"
  width={200}
  height={200}
  priority={false}  // 重要でない画像は遅延
/>
```

## エラーハンドリング

### エラーバウンダリ
- `app/error.tsx` - グローバルエラー
- `app/(authenticated)/error.tsx` - 認証後のエラー
- 各機能ディレクトリにも`error.tsx`を配置

### try-catch パターン
```typescript
// ✅ 適切なエラーハンドリング
try {
  const { data, error } = await supabase
    .from('practices')
    .insert(newPractice)
    .select()
    .single()
  
  if (error) throw error
  
  // 成功時の処理
} catch (error) {
  // エラーハンドリング
  console.error('データ登録エラー:', error)
  // ユーザーにエラーメッセージを表示
}
```

## セキュリティ

### 環境変数
```typescript
// ✅ クライアント公開: NEXT_PUBLIC_ プレフィックス
process.env.NEXT_PUBLIC_SUPABASE_URL

// ❌ サーバーのみ: プレフィックスなし
process.env.SUPABASE_SERVICE_KEY
```

### XSS対策
- ユーザー入力は常にサニタイズ
- `dangerouslySetInnerHTML`は避ける
- URLパラメータをそのまま表示しない

## アクセシビリティ

- セマンティックHTML使用（`<button>`, `<nav>`など）
- `aria-label`を適切に設定
- キーボード操作対応
- フォーカス管理（モーダル、ドロップダウン）